\documentclass[sigplan,screen,acmsmall]{acmart}%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

\newif\ifdraft\drafttrue{}
\newif\iflater\latertrue{}

\PassOptionsToPackage{names,dvipsnames}{xcolor}

\settopmatter{printfolios=false,printccs=false,printacmref=false}
\setcopyright{none}

\usepackage{listings}
\usepackage{subcaption}

\definecolor{dkred}{rgb}{0.7,0,0}
\definecolor{dkblue}{rgb}{0,0,0.7}
\definecolor{notered}{rgb}{0.85,0,0}
\definecolor{dkpurple}{HTML}{4e02eb}
\definecolor{dkgreen}{HTML}{006329}
\definecolor{teal}{HTML}{007982}
\definecolor{fuchsia}{HTML}{8C368C}

\newcommand{\comm}[3]{\ifdraft\textcolor{#1}{[#2: #3]}\fi}
\newcommand{\cn}{\ifdraft{\color{blue} [CITE]}\fi}
\newcommand{\hg}[1]{\comm{dkred}{HG}{#1}}
\newcommand{\tr}[1]{\comm{dkblue}{TR}{#1}}
\newcommand{\bcp}[1]{\comm{dkpurple}{BCP}{#1}}
\newcommand{\jwc}[1]{\comm{dkgreen}{JWC}{#1}}
\newcommand{\outline}[1]{\ifdraft{\color{teal} #1}\fi}

\newcommand{\bq}{\texttt{base\_quickcheck}}
\newcommand{\name}{\texttt{waffle\_house}}
\newcommand{\tool}{Waffle House}

\newcommand{\secref}[1]{\S\ref{#1}}

\newcommand{\proposecut}[1]{\ifdraft{\color{gray} [#1]}\fi}
\newcommand{\proposechange}[2]{\ifdraft{\color{gray} {#1}
    $\rightarrow$ #2}\else #2\fi}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\newtheorem{claim}{Claim}

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}


%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2025}
\acmYear{2025}
\acmDOI{XXXXXXX.XXXXXXX}
%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Conference acronym 'XX]{Make sure to enter the correct
  conference title from your rights confirmation email}{June 03--05,
  2018}{Woodstock, NY}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
\acmISBN{978-1-4503-XXXX-X/2025/02}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}


%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Fail Faster}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Cynthia Richey}
\affiliation{%
  \institution{University of Pennsylvania}
  \city{Philadelphia}
  \state{Pennsylvania}
  \country{USA}
}

\author{Joseph W. Cutler}
\affiliation{%
  \institution{University of Pennsylvania}
  \city{Philadelphia}
  \state{Pennsylvania}
  \country{USA}}

\author{Harrison Goldstein}
\affiliation{%
  \institution{University of Maryland}
  \city{College Park}
  \state{Maryland}
  \country{USA}
}

\author{Benjamin C. Pierce}
\affiliation{%
 \institution{University of Pennsylvania}
 \city{Philadelphia}
 \state{Pennsylvania}
 \country{USA}}
%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Richey et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract} \tr{Abstract needs a lot of work.}
Property-based testing (PBT) is a software testing approach that verifies a system against a large suite of automatically-generated inputs. Since testing pipelines typically run under strict time constraints, PBT generators must produce inputs as quickly as possible to maximize the likelihood of finding bugs in the time available. However, existing PBT libraries often prioritize generality at the cost of performance. We introduce \texttt{waffle\_house}, a high-performance generator library that uses staging, a lightweight compilation technique, to eliminate many common generator abstractions. To evaluate \texttt{waffle\_house}, we design a novel benchmarking methodology that compares generators based on program equivalence, isolating performance improvements from differences in input distribution. Using this methodology, we compare \texttt{waffle\_house} to a leading generator library, and, through extensive evaluation over a diverse range of generators, demonstrate that \texttt{waffle\_house} significantly improves generation speed and resource efficiency while matching \texttt{base\_quickcheck}'s expressiveness.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%

\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10011007</concept_id>
       <concept_desc>Software and its engineering</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011006</concept_id>
       <concept_desc>Software and its engineering~Software notations and tools</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011006.10011072</concept_id>
       <concept_desc>Software and its engineering~Software libraries and repositories</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011006.10011041.10011046</concept_id>
       <concept_desc>Software and its engineering~Translator writing systems and compiler generators</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering}
\ccsdesc[500]{Software and its engineering~Software notations and tools}
\ccsdesc[500]{Software and its engineering~Software libraries and repositories}
\ccsdesc[500]{Software and its engineering~Translator writing systems and compiler generators}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Property-based testing, Generators, Staging, Meta-programming}
%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.

\received{--}
\received[revised]{--}
\received[accepted]{--}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
Property-based testing (PBT) is a widely-used testing framework consisting of
two key components: a set of \textit{properties} that a system must satisfy, and
a large number of \textit{inputs} to that system. In contrast to traditional
unit testing, where inputs are hand-written, PBT users create a random-input
\textit{generator} that automatically produces inputs. Sometimes, this process
can itself be automated through the use of PBT libraries that synthesize
generators from type definitions; however, when inputs are required to maintain
invariants not communicated by the type, users must write a custom generator (or
filter out a broad class of invalid inputs). 

Writing ``good" generators—those that uncover more bugs in the system under
test—is challenging. Much effort has been dedicated to this problem, often by
developing sophisticated domain-specific languages for specifying constrained
generators. However, these approaches do not always reflect the needs of real
PBT users. Under ideal conditions, a PBT suite would continue to run
until it stopped finding bugs, real-world usage patterns are very different; a
study of expert PBT users reported time budgets of between 50 milliseconds and
30 seconds for their test suites~\cite{inpractice}. Consequently, generation
time is a significant factor in PBT efficacy---that is, if a generator can
produce inputs twice as fast, it has twice as many chances within a given time
bound to find a bug. Therefore, it is imperative that PBT libraries are built
with efficiency in mind.

To better understand and address performance challenges in the landscape of PBT
generators, we explore popular libraries across several widely-used programming
languages. We find that the flexibility of these libraries comes at a cost to 
performance,
introducing abstraction overhead, frequent boxing and unboxing, and avoidable
allocations (which lead to costly garbage collection pauses). We focus primarily 
on OCaml's \bq, selected for its efficiency relative to other OCaml PBT libraries 
and its integration with industrial build systems, where it is expected to run 
within tight time constraints. These
inefficiencies raise a fundamental question: how can PBT libraries produce code
that is both efficient \textit{and} general? By analyzing
\bq\ and similar libraries in other languages \tr{Rust?
More?}, we provide a broader perspective on common performance challenges in PBT
and explore potential strategies for more efficient generator implementations.

Our solution is \name, a generator library that preserves
\bq’s functionality while improving performance through
\textit{staged metaprogramming} (staging). Staging is a lightweight,
domain-specific compilation technique that allows us to completely eliminate the
runtime overhead of many common generator abstractions. \jwc{This relies on the fact that the code of generators is known statically at compile time} For instance, in
\name, monadic operations are zero-cost.
\name’s staged eliminates unnecessary allocations,
generates static control structures, and leverages unboxed integer libraries to
achieve performance improvements over \texttt{base\_quickcheck}, making it
well-suited to real-world PBT applications.

We present a new methodology for evaluating the relative effectiveness of PBT
generators. Prior work has compared generators based on bug-finding ability: 
generators are considered equally effective if they find bugs in a
system at the same rate over a large number of trials ~\cite{etna}. However,
because \name\ preserves the semantics of
\bq, a \name\ generator produces exactly
the same inputs as its \bq\ counterpart. By comparing
generators based on \textit{program equality}, we ensure that any speedups in
bug-finding ability stem from performance enhancements rather than variations in
input distribution. This approach establishes a foundation for benchmarking
optimizations that enhance performance without compromising expressiveness.

Finally, we conduct an extensive evaluation, implementing both type-derived and
custom generators in \name\ and \bq. Our
generators produce a diverse range of inputs, including recursive data
structures, lambda calculus terms, and regular expressions. We benchmark
generation time, resource usage, and time-to-failure for each pair of staged and
unstaged generators, demonstrating that \name\ achieves
significant gains in speed and resource.

In summary, we dramatically improve the bug-finding effectiveness of PBT generators
by optimizing them for speed. In speicific, we make the following contributions:
\begin{enumerate}
    \item An empirical analysis of the sources of inefficiency in PBT
    generators. 
    \item A library, \name, which offers efficient generator functions through the
    use of staged metaprogramming; this is the first known application of metaprogramming to PBT.
    \item The insight that generators should be compared by program equality 
    \item An evaluation demonstrating the improved performance of generators constructed
    using our library in a controlled comparison.

\end{enumerate}

\section{Background}



\subsection{Property-Based Testing}
\jwc{Mention the shape of PBT dsls, give running example here (or maybe earlier!). Monadic dsls.}


\begin{lstlisting}
let int_pair : (int * int) Bq.t =
  let%bind x = int 0 100 in
  let%bind y = int 0 x in
  return (x,y)
\end{lstlisting}

\jwc{\texttt{int} here is really \texttt{int\_uniform\_inclusive}. I also think we should completely omit named arguments in the paper so we don't confuse with splices.}

\subsection{Staged Metaprogramming}

\jwc{A good quick presentation of staged metaprogramming is here, in section 6.
https://www.cl.cam.ac.uk/~jdy22/papers/a-typed-algebraic-approach-to-parsing.pdf
}

\subsection{Other Languages and Libraries}

\tr{Here's where we talk about what's going on in the world, and ultimately make the argument that \bq{} is the best tool to reproduce.}

\jwc{Note that this explanation require some prior note of exactly *why* BQ is slow... i.e. the abstraction overhead of the library is high.}

\jwc{
  \begin{itemize}
    \item Scala. Functional abstractions like QC generators are known to be costly in Scala, that's why they have LMS (in Scala 2, and Macros in Scala 3). Example: parser combinators (``On Staged Parser Combinators for Efficient Data Processing''), functional data structures (\href{https://ppl.stanford.edu/papers/popl13_rompf.pdf}{Link}), web programming (``Efficient High-Level Abstractions for Web Programming'').
    Al of this should still work in scala. Could easily be incorporated into ScalaCheck, with minor modification: ScalaCheck uses a state monad to thread around the seed, instead of a stateful one (like BQ), or a splittable one (like Haskell). So you have to adapt to that. But same diff.
    \item Haskell: GHC does a lot of these optimizations already, since the code is pure. Since QC generators are relatively small programs,
    GHC has little trouble specializing them. Of course, this is not guaranteed. A version of this idea can easily be ported to the original QC with template haskell, to guarantee
    the highest-performance generators.
    \item Rust: Not GC'd, so no alloc overhead but bind'd generators still dispatch through runtime data.
  \end{itemize}
}

\subsection{\bq}

\tr{Discuss BQ, including type-derived generators.}

\section{Why is \bq\ slow, and how can we fix it?}

\jwc{
  \begin{itemize}
    \item How does BQ work?
    \begin{itemize}
      \item The basic generator type: \texttt{'a generator = int -> SR.t -> 'a}. Size and random seed to deterministic value. (note: \texttt{SR.t} is a mutable seed)
      \item Also two inverse functions, \texttt{create}, and \texttt{generate}.
      \item This gets a monad intance in the obvious way (show code).
      \item Also show the code for \texttt{int}, how it calls the underlying SR function.
    \end{itemize}
    \item Note that \emph{extensionally} \texttt{generate (create (fun size random -> e)) size random = e}, but the OCaml compiler does not always perform this optimization, or do the inlining required to expose it.
    (When sufficiently obfuscated behind returns and binds ...) This program compiles to code that (1) allocates the closure for `e', (2) passes it to create (which returns the closure), and then calls (3) generate, which immediately jumps into the closure.
    \item Show allocation benchmarks of the running example, versus the version where you inline everything.
  \end{itemize}
}


% In OCaml, garbage collection is the killer.

% This generator generates a list of bools. To generate a list of 100 bools, it allocates \texttt{4808.00w (minor)}, and runs for an average of
% 3.9us. Merely representing a list of bools of length 100 requires 300 words in OCaml, so this generator allocates 16 times more than the theoretical minimum.

% \jwc{Mention ppx_jane and let syntax}

% \begin{lstlisting}
% let gen_list_bool =
%   fixed_point (fun gl ->
%     let%bind n = size in
%     if n <= 0 then return [] else
%       let%bind x = bool in
%       let%bind xs = with_size ~size:(n-1) gl in
%       return (x :: xs)
%   )
% \end{lstlisting}

% On the other hand, this generator allocates only 303w, and runs for 0.7us, to generate the same list of 100 bools.
% \begin{lstlisting}
%   let rec gen_list_bool_faster ~size ~random  = 
%     if size <= 0 then []
%     else (Unboxed_splitmix.bool random)::(gen_list_bool_faster ~size:(size - 1) ~random)
% \end{lstlisting}



\tr{Each of these consist of an explanation of the problem and pseudocode outlining the solution.}
\subsubsection{Monadic bind}

\jwc{
  \begin{itemize}
    \item Naked binds like \texttt{Bind}
  \end{itemize}
}

\subsubsection{Expensive Combinators}
\jwc{Many combinators like \texttt{union} and \texttt{weighted\_union} needlessly allocate large data structures in the generation hot path.
Using a combination of staging and more careful algorithm design, we can avoid this overhead.
}

\begin{lstlisting}
  let of_weighted_list alist =
  let weights, values = List.unzip alist in
  let value_array = Array.of_list values in
  let total_weight, cumulative_weight_array =
    let array = Array.init (Array.length value_array) ~f:(fun _ -> 0.) in
    let sum =
      List.foldi weights ~init:0. ~f:(fun index acc weight ->
        let acc' = acc +. weight in
        array.(index) <- acc';
        acc'
      )
    in
    sum, array
  in
  create (fun ~size:_ ~random ->
    let choice = Splittable_random.float random ~lo:0. ~hi:total_weight in
    match
      Array.binary_search
        cumulative_weight_array
        ~compare:Float.compare
        `First_greater_than_or_equal_to
        choice
    with
    | Some index -> value_array.(index)
    | None -> assert false
   )
\end{lstlisting}

\jwc{This builds the cdf of the distribution, samples from 0 to the total, and binary searches through the array to find the bucket.}
\jwc{Allocating this array is unnecessary: we can simply compute the total weight, sample \texttt{x} between 0 and the total, and then walk the list accumulating the sum, until the accumulator exceeds \texttt{x}. Since in practice the list of possible options is quite small (usually at most 10 in practice), the linear time scan is going to be much faster.}
\jwc{(The point of this para will just be to emphasize that it's almost always better to be allocation-aware, instead of algorithmically clever.)}

\jwc{Moreover, the possible options is almost always statically known in practice: you use weightedunion to generate (say) a datatype with possible
variants, whose options are known at compile time.
Put more simply, you basically always call weighted union with an \emph{explicit list}: For this reason, you should not have to incur the cost of allocating this list at runtime.}

% \subsubsection{Function call overhead}
\subsubsection{Boxed integers}

\section{\name: A Library for Staging Generators}

\jwc{
  \begin{itemize}
    \item To eliminate this runtime overhead and generate efficient code, we do a usual ``binding-time analysis''.
    \item The crux of this binding-time analysis is that while generators are `just' values of type \texttt{'a t}, in practice they are always \emph{completely statically defined}: one never
    computes a generator dynamically at test time.
  \end{itemize}
}

\subsection{Basic Design}

\begin{lstlisting}
type 'a gen = int code -> Random.t code -> 'a code

let return (cx : 'a code) : 'a gen = fun size_c random_c -> cx

let bind (g : 'a gen) (k : 'a -> 'b gen) : 'b gen =
  fun size_c random_c ->
    .<
      let x = .~(g size_c random_c) in
      .~(
        (k .<x>.) size_c random_c
      )
    >.

let int (lo : int code) (hi : int code) : int code gen =
  fun size_c random_c ->
    .< SR.int .~random_c .~lo .~hi >.
\end{lstlisting}

\jwc{Conversion to a bq generator}

\begin{lstlisting}
let to_bq (g : 'a code gen) : ('a Bq.t) code =
  .<
    Bq.create (fun size random ->
      .~(g .<size>. .<random>.)
    )
  >.
\end{lstlisting}

\jwc{Then show the running example, with }

\begin{lstlisting}
let int_pair_staged : ((int * int) code) gen =
  let%bind x = int 0 100 in
  let%bind y = int 0 x in
  return (x,y)

let int_pair : (int * int) Bq.t code = to_bq int_pair_staged
====
.<
  Bq.create (fun size random ->
    let x = SR.int random 0 100 in
    let y = SR.int random 0 x in
    (x,y)
  )
.>
\end{lstlisting}

\jwc{So if you write with the \texttt{gen} combinators and then only call \texttt{to\_bq} at the end, you get something that includes no creates/generates!}

\jwc{Show benchmark difference between these two generators.}

\subsection{Staging More Combinators}

\jwc{Weighted unions: recall that we should not need to materialize}

\subsection{Basic Design}


\jwc{Note: tradeoff between maintaining the effect ordering and even more performance. }

\jwc{Note with bind that we don't split because it's imperatively updated. Note that this omits the need to use SR, but we use it to maintain backwards compat.}

\subsection{Comparing Generators}

\jwc{NOTE: we should test generator speed across both languages, but speed -> bugfinding ability in only OCaml.}
\jwc{
  Baseline generators to test speed in both languages:
  \begin{itemize}
    \item Single int
    \item Pair of ints, constrained
    \item List of ints
  \end{itemize}
}

\subsubsection{Existing Approaches}
\subsubsection{Equality up to Program Equality}
\subsubsection{Effect Ordering}
\subsubsection{PBT for PBT}
\subsubsection{Does maintaining program equality in \name\ affect performance?}
\section{Evaluation}
\subsubsection{Implementation}
\subsection{Benchmarking speed \& resource usage}
\subsection{Impact on bug-finding ability}
\section{Conclusion \& Future Work}
%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{bib}


%%
%% If your work has an appendix, this is the place to put it.
\end{document}
\endinput
%%
%% End of file `sample-sigplan.tex'.
